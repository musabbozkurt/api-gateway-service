GATEWAY_BASE_URL: ${GATEWAY_BASE_URL_ENV:http://localhost:8080}

spring:
  application:
    name: swagger-application

  mvc:
    pathmatch:
      matching-strategy: ant_path_matcher

  jackson:
    default-property-inclusion: non_null
    serialization:
      indent-output: true

  datasource:
    url: jdbc:h2:mem:testdb
    username: sa
    password: ${H2_PASSWORD:sa}
    driverClassName: org.h2.Driver

  h2:
    console:
      enabled: true
      path: /h2-console

  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5673}
    virtual-host: /
    connection-timeout: 0
    template:
      retry:
        enabled: true
        initial-interval: 1000
        max-retries: 2
        max-interval: 3000
        multiplier: 1

  cloud:
    function:
      definition: studentConsumer
    #This makes the queue durable so that if the application is down, the messages would still be published.
    #These are then processed once the application is up again.
    #Instruction defines exchange and queue names
    #Dead Letter queue is created automatically and bound to main instruction queue.
    stream:
      bindings:
        swaggerProducer-out-0:
          destination: swagger_events_destination
          group: swagger_events_group
        studentConsumer-in-0:
          destination: student_events_destination
          group: student_events_group
          consumer:
            maxAttempts: 1
            concurrency: 1
      rabbit:
        bindings:
          studentConsumer-in-0:
            consumer:
              exchangeType: fanout
              auto-bind-dlq: true
              requeueRejected: false
              republish-to-dlq: true
              dlq-dead-letter-exchange:
              dlq-ttl: 300000
    config:
      uri: ${CONFIG_SERVER_URI:http://localhost:8888}
      profile: development
      label: main
      fail-fast: true # true: if config server is down, this service will not start

  config:
    import: "optional:configserver:" # "optional:configserver:${CONFIG_SERVER_URI:http://localhost:8888}"

management:
  tracing:
    sampling:
      probability: 1.0
  observations:
    key-values:
      application: ${spring.application.name}
  endpoints:
    web:
      exposure:
        include: health,refresh # curl --location --request POST 'http://localhost:8082/actuator/refresh'

logging:
  pattern:
    level: "%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"

server:
  port: 8082

springdoc:
  api-docs:
    path: /swagger/api-docs
  swagger-ui:
    path: /swagger-ui.html # http://localhost:8082/swagger-ui/index.html
    enabled: true

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_CLIENT_SERVICE_URL:http://localhost:8761/eureka}
